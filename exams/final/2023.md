---
sidebar_position: 1
title: 2023年期末考试
---

# 2023年CSSE1001/7030期末考试

:::note
本页面提供的是2023年期末考试题目及解析示例。实际考试题目可能会有所不同。
:::

## 考试信息

- **考试时间**：3小时
- **总分**：100分
- **及格线**：50分
- **考试形式**：笔试，不允许使用计算器或任何电子设备
- **题型**：选择题、填空题、简答题、程序分析题、编程题

## 第一部分：选择题（20分）

每题1分，共20分。选择一个最适合的选项。

### 问题1
下面哪个描述是关于Python字典（dict）的正确陈述？
- A. 字典中的键必须是不可变的
- B. 字典是有序的集合
- C. 字典不能包含重复的值
- D. 字典的键和值必须是相同的数据类型

**答案**：A. 字典中的键必须是不可变的（列表和字典等可变对象不能作为键，但可以作为值）

### 问题2
以下哪个不是Python中的面向对象编程概念？
- A. 继承
- B. 多态
- C. 封装
- D. 重载

**答案**：D. 重载（Python不支持传统意义上的函数重载，尽管有类似功能的实现方式）

### 问题3-20
（此处省略其他选择题）

## 第二部分：填空题（15分）

每空1分，共15分。在空白处填写合适的代码或表达式。

### 问题21
完成以下代码，创建一个名为`Point`的类，并实现其`__init__`和`__str__`方法：

```python
class Point:
    def _______(self, x, y):
        self.x = x
        self.y = y
    
    def _______(self):
        return f"Point({self.x}, {self.y})"
```

**答案**：
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"Point({self.x}, {self.y})"
```

### 问题22
完成以下代码，使用文件操作创建一个将用户输入的文本保存到文件中的程序：

```python
filename = "user_input.txt"
user_text = input("请输入要保存的文本：")

with open(filename, "_______") as file:
    file._______(user_text)

print(f"文本已保存到{filename}")
```

**答案**：
```python
filename = "user_input.txt"
user_text = input("请输入要保存的文本：")

with open(filename, "w") as file:
    file.write(user_text)

print(f"文本已保存到{filename}")
```

### 问题23-30
（此处省略其他填空题）

## 第三部分：简答题（25分）

### 问题31（10分）
解释Python中的异常处理机制，并给出一个例子，说明如何捕获和处理不同类型的异常。

**答案**：

Python的异常处理机制允许程序在遇到错误时能够优雅地处理错误，而不是直接崩溃。

异常处理的基本组成部分：
1. **try**：包含可能引发异常的代码
2. **except**：指定如何处理异常
3. **else**：如果try块没有引发异常，执行此部分代码
4. **finally**：无论是否发生异常，都会执行此部分代码

例子：
```python
def divide_numbers():
    try:
        num1 = float(input("请输入第一个数字："))
        num2 = float(input("请输入第二个数字："))
        result = num1 / num2
    except ValueError:
        print("错误：请输入有效的数字")
        return None
    except ZeroDivisionError:
        print("错误：除数不能为零")
        return None
    except Exception as e:
        print(f"发生未预期的错误：{e}")
        return None
    else:
        print("计算成功！")
        return result
    finally:
        print("无论是否发生异常，这里的代码都会执行")

result = divide_numbers()
if result is not None:
    print(f"结果是：{result}")
```

这个例子展示了如何处理不同类型的异常：
- ValueError：处理用户输入非数字的情况
- ZeroDivisionError：处理除以零的情况
- 通用Exception：捕获所有其他类型的异常
- else语句用于在没有异常时执行代码
- finally语句确保无论如何都会执行清理工作

### 问题32（15分）
设计一个简单的银行账户系统，描述你将如何使用面向对象编程的概念（如类、继承、封装等）来实现它。说明你的设计中的主要类和它们之间的关系。

**答案**：

银行账户系统的面向对象设计：

**1. 基类：`Account`**
```python
class Account:
    def __init__(self, account_number, owner_name, balance=0):
        self._account_number = account_number  # 封装：使用下划线表示保护属性
        self._owner_name = owner_name
        self._balance = balance
    
    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        if 0 < amount <= self._balance:
            self._balance -= amount
            return True
        return False
    
    def get_balance(self):
        return self._balance
    
    def get_account_info(self):
        return {
            "account_number": self._account_number,
            "owner_name": self._owner_name,
            "balance": self._balance,
            "account_type": "基本账户"
        }
```

**2. 子类：`SavingsAccount`（继承自`Account`）**
```python
class SavingsAccount(Account):
    def __init__(self, account_number, owner_name, balance=0, interest_rate=0.01):
        super().__init__(account_number, owner_name, balance)  # 调用父类构造函数
        self._interest_rate = interest_rate
    
    def add_interest(self):
        # 计算利息并添加到余额
        interest = self._balance * self._interest_rate
        self._balance += interest
        return interest
    
    def get_account_info(self):  # 多态：重写父类方法
        info = super().get_account_info()
        info["account_type"] = "储蓄账户"
        info["interest_rate"] = self._interest_rate
        return info
```

**3. 子类：`CheckingAccount`（继承自`Account`）**
```python
class CheckingAccount(Account):
    def __init__(self, account_number, owner_name, balance=0, overdraft_limit=100):
        super().__init__(account_number, owner_name, balance)
        self._overdraft_limit = overdraft_limit
    
    def withdraw(self, amount):  # 多态：重写父类方法
        if amount > 0 and self._balance + self._overdraft_limit >= amount:
            self._balance -= amount
            return True
        return False
    
    def get_account_info(self):
        info = super().get_account_info()
        info["account_type"] = "支票账户"
        info["overdraft_limit"] = self._overdraft_limit
        return info
```

**4. 银行管理类：`Bank`**
```python
class Bank:
    def __init__(self, name):
        self.name = name
        self.accounts = {}
    
    def add_account(self, account):
        account_number = account._account_number  # 在实际代码中可能需要getter方法
        self.accounts[account_number] = account
    
    def get_account(self, account_number):
        return self.accounts.get(account_number)
    
    def transfer(self, from_acc_num, to_acc_num, amount):
        from_acc = self.get_account(from_acc_num)
        to_acc = self.get_account(to_acc_num)
        
        if from_acc and to_acc:
            if from_acc.withdraw(amount):
                to_acc.deposit(amount)
                return True
        return False
```

**设计说明**：
1. **继承**：`SavingsAccount` 和 `CheckingAccount` 继承自 `Account` 基类
2. **封装**：使用下划线前缀 (`_`) 保护属性，通过方法控制访问
3. **多态**：子类重写父类的方法（如 `withdraw` 和 `get_account_info`）
4. **组合**：`Bank` 类包含多个 `Account` 对象

**类之间的关系**：
- `Account` 是基类，定义了所有账户共有的属性和方法
- `SavingsAccount` 和 `CheckingAccount` 是特殊类型的账户，继承并扩展了基本账户功能
- `Bank` 组合了多个账户对象，并提供额外的功能，如转账

## 第四部分：程序分析题（15分）

### 问题33（15分）
分析以下程序的运行过程和结果。找出程序中的任何错误，并进行修正。解释你的修改原因。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def birthday(self):
        self.age += 1
    
    def __str__(self):
        return f"{self.name}, {self.age} 岁"

class Student(Person):
    def __init__(self, name, age, student_id):
        self.name = name
        self.age = age
        self.student_id = student_id
    
    def __str__(self):
        return f"{self.name}, {self.age} 岁, 学号: {self.student_id}"

# 创建对象
p = Person("张三", 30)
s = Student("李四", 20, "12345")

# 生日
p.birthday()
s.birthday()

# 打印信息
print(p)
print(s)
```

**答案**：

程序分析：
1. 创建一个`Person`类，有姓名和年龄属性，以及生日方法用于增加年龄
2. 创建一个`Student`类继承自`Person`，增加了学号属性
3. 创建`Person`和`Student`对象，调用生日方法，最后打印信息

**错误与修正**：

主要错误：`Student`类的`__init__`方法没有调用父类的构造函数，而是重新定义了相同的属性，这违反了继承的原则，导致代码重复。

修正后的代码：
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def birthday(self):
        self.age += 1
    
    def __str__(self):
        return f"{self.name}, {self.age} 岁"

class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)  # 调用父类的构造函数
        self.student_id = student_id
    
    def __str__(self):
        return f"{self.name}, {self.age} 岁, 学号: {self.student_id}"

# 创建对象
p = Person("张三", 30)
s = Student("李四", 20, "12345")

# 生日
p.birthday()
s.birthday()

# 打印信息
print(p)  # 输出: 张三, 31 岁
print(s)  # 输出: 李四, 21 岁, 学号: 12345
```

**修改原因**：
1. 在子类的`__init__`方法中，应该调用`super().__init__(name, age)`来初始化从父类继承的属性，而不是重复定义相同的代码。
2. 这样做的好处是：
   - 避免代码重复
   - 如果父类的`__init__`方法改变，子类会自动继承这些变化
   - 如果父类在构造函数中有其他逻辑，子类也会执行这些逻辑

修改后的程序将正确地使用继承，`Student`对象不仅会继承`Person`的属性，还会继承其方法（如`birthday`）的实现。

## 第五部分：编程题（25分）

### 问题34（25分）
实现一个简单的图书管理系统，包含以下功能：
1. 图书类（Book）：包含书名、作者、ISBN和库存数量等属性
2. 图书馆类（Library）：管理图书的添加、借出、归还和查询
3. 用户交互：实现一个简单的命令行界面，允许用户执行上述操作

**答案**：

```python
class Book:
    def __init__(self, title, author, isbn, quantity=1):
        self.title = title
        self.author = author
        self.isbn = isbn
        self.quantity = quantity
        self.available = quantity  # 可用数量初始等于总数量
    
    def __str__(self):
        return f"《{self.title}》 作者: {self.author}, ISBN: {self.isbn}, 库存: {self.available}/{self.quantity}"

class Library:
    def __init__(self, name):
        self.name = name
        self.books = {}  # 使用ISBN作为键
    
    def add_book(self, book):
        if book.isbn in self.books:
            # 更新已有图书的数量
            existing_book = self.books[book.isbn]
            existing_book.quantity += book.quantity
            existing_book.available += book.quantity
            return f"更新了《{book.title}》的库存，现有 {existing_book.quantity} 本"
        else:
            # 添加新书
            self.books[book.isbn] = book
            return f"添加了新书《{book.title}》，库存 {book.quantity} 本"
    
    def borrow_book(self, isbn):
        if isbn not in self.books:
            return "错误: 该ISBN编号的书不存在"
        
        book = self.books[isbn]
        if book.available <= 0:
            return f"抱歉，《{book.title}》目前无库存可借"
        
        book.available -= 1
        return f"成功借出《{book.title}》，剩余库存：{book.available}"
    
    def return_book(self, isbn):
        if isbn not in self.books:
            return "错误: 该ISBN编号的书不存在"
        
        book = self.books[isbn]
        if book.available < book.quantity:
            book.available += 1
            return f"成功归还《{book.title}》，当前可用库存：{book.available}"
        else:
            return f"错误: 所有《{book.title}》均在库，无法归还更多"
    
    def search_book(self, keyword):
        results = []
        for book in self.books.values():
            if (keyword.lower() in book.title.lower() or 
                keyword.lower() in book.author.lower() or 
                keyword in book.isbn):
                results.append(book)
        return results
    
    def display_all_books(self):
        if not self.books:
            return "图书馆目前没有藏书"
        
        result = f"{self.name}的藏书列表：\n"
        for i, book in enumerate(self.books.values(), 1):
            result += f"{i}. {book}\n"
        return result.strip()


def main():
    library = Library("Python编程图书馆")
    
    # 添加示例书籍
    library.add_book(Book("Python编程入门", "张三", "9787111111111", 5))
    library.add_book(Book("数据结构与算法", "李四", "9787222222222", 3))
    library.add_book(Book("机器学习实践", "王五", "9787333333333", 2))
    
    while True:
        print("\n===== 图书馆管理系统 =====")
        print("1. 查看所有图书")
        print("2. 添加新书")
        print("3. 借书")
        print("4. 还书")
        print("5. 搜索图书")
        print("0. 退出系统")
        
        choice = input("请选择操作 (0-5): ").strip()
        
        if choice == "1":
            print(library.display_all_books())
        
        elif choice == "2":
            title = input("请输入书名: ")
            author = input("请输入作者: ")
            isbn = input("请输入ISBN: ")
            try:
                quantity = int(input("请输入数量: "))
                if quantity <= 0:
                    print("数量必须为正整数")
                    continue
            except ValueError:
                print("请输入有效的数字")
                continue
            
            result = library.add_book(Book(title, author, isbn, quantity))
            print(result)
        
        elif choice == "3":
            isbn = input("请输入要借阅图书的ISBN: ")
            result = library.borrow_book(isbn)
            print(result)
        
        elif choice == "4":
            isbn = input("请输入要归还图书的ISBN: ")
            result = library.return_book(isbn)
            print(result)
        
        elif choice == "5":
            keyword = input("请输入搜索关键词: ")
            results = library.search_book(keyword)
            if results:
                print(f"找到 {len(results)} 本相关图书：")
                for i, book in enumerate(results, 1):
                    print(f"{i}. {book}")
            else:
                print("未找到相关图书")
        
        elif choice == "0":
            print("感谢使用图书馆管理系统，再见！")
            break
        
        else:
            print("无效的选择，请重新输入")


if __name__ == "__main__":
    main()
```

上述实现包括：
1. **Book类**：包含书名、作者、ISBN、总数量和可用数量
2. **Library类**：实现添加、借出、归还和搜索图书的功能
3. **用户交互**：通过命令行界面实现与用户的交互
4. **错误处理**：处理无效输入、库存不足等异常情况

系统特点：
- 使用ISBN唯一标识图书
- 跟踪图书的总数量和可用数量
- 支持按关键词搜索（书名、作者、ISBN）
- 提供友好的用户交互界面

## 评分标准

- **选择题和填空题**：答案完全正确得满分，否则不得分。
- **简答题**：根据答案的完整性、准确性和清晰度评分。
- **程序分析题**：找出所有错误并正确修改（60%），解释修改原因（40%）。
- **编程题**：
  - 功能完整性（50%）
  - 代码设计和组织（20%）
  - 错误处理（15%）
  - 代码风格（10%）
  - 文档/注释（5%） 